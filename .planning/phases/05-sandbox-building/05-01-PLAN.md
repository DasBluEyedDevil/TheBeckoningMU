---
phase: 05-sandbox-building
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - beckonmu/web/builder/sandbox_bridge.py
  - beckonmu/web/builder/sandbox_builder.py
  - beckonmu/web/builder/views.py
  - beckonmu/web/builder/urls.py
autonomous: true

must_haves:
  truths:
    - "Approving a project triggers automatic sandbox creation via API"
    - "Sandbox rooms and exits are created as real Evennia objects"
    - "Room attributes (description, V5 settings) are correctly applied"
    - "Exits connect sandbox rooms bidirectionally matching the web map layout"
    - "BuildProject.sandbox_room_id is set to the entry room's database ID"
    - "Project status transitions from 'approved' to 'built' on success"
  artifacts:
    - path: "beckonmu/web/builder/sandbox_bridge.py"
      provides: "Thread-safe bridge for Django-to-Evennia communication"
      exports: ["create_sandbox_from_project", "run_in_main_thread"]
    - path: "beckonmu/web/builder/sandbox_builder.py"
      provides: "Room/exit creation logic from map_data"
      exports: ["build_sandbox_area"]
    - path: "beckonmu/web/builder/views.py"
      provides: "BuildSandboxView API endpoint"
      min_lines: 50
  key_links:
    - from: "views.BuildSandboxView"
      to: "sandbox_bridge.create_sandbox_from_project"
      via: "POST handler after staff approval"
      pattern: "create_sandbox_from_project\(project_id\)"
    - from: "sandbox_bridge"
      to: "sandbox_builder.build_sandbox_area"
      via: "run_in_main_thread wrapper"
      pattern: "run_in_main_thread\(build_sandbox_area"
    - from: "sandbox_builder"
      to: "evennia.create_object"
      via: "Evennia API for room/exit creation"
      pattern: "create_object\(typeclasses.rooms.Room"
---

<objective>
Create the bridge layer and automatic sandbox building system that converts approved BuildProjects into real Evennia rooms and exits.

Purpose: Eliminate the manual batch script execution step by automatically creating sandbox areas when staff approves a project. This is the critical infrastructure that connects the web builder to the live game world.
Output: Working sandbox creation system with thread-safe Django-to-Evennia bridge, room/exit builder, and API endpoint.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md

**Key Prior Decisions (from STATE.md):**
- Phase 5 needs run_in_main_thread() integration testing -- highest architectural risk
- BuildProject has status lifecycle: draft → submitted → approved → built → live
- BuildProject.sandbox_room_id field exists for linking to created sandbox
- Exporter already generates batch commands -- we need to execute equivalent logic programmatically
- Schema versioning (schema_version: 1) is in map_data defaults

**Architecture Context:**
- Evennia runs game loop in main thread; Django web runs in separate thread
- Must use Evennia's run_in_main_thread() for object creation
- Room typeclass: beckonmu.typeclasses.rooms.Room
- Exit typeclass: beckonmu.typeclasses.exits.Exit
- Sandbox rooms tagged with: web_builder, project_{id}, sandbox

**Current BuildProject.map_data structure:**
```json
{
  "schema_version": 1,
  "rooms": {"1": {"name": "...", "description": "...", "x": 0, "y": 0, "v5": {...}}},
  "exits": {"1": {"name": "...", "source": "1", "target": "2", "aliases": [...]}},
  "objects": {...},
  "next_room_id": N,
  "next_exit_id": N,
  "next_object_id": N
}
```

**Current exporter.py pattern to replicate:**
- Creates rooms with aliases like `_bld_{project_id}_{room_id}`
- Sets V5 attributes: location_type, day_night, danger_level, hunting_modifier, territory_owner
- Sets haven_ratings if location_type is "haven"
- Creates exits between rooms using source/target IDs
- Tags everything with web_builder and project_{project_id}
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sandbox_bridge.py with thread-safe Evennia integration</name>
  <files>beckonmu/web/builder/sandbox_bridge.py</files>
  <action>
Create the bridge module that safely calls Evennia APIs from Django web context.

**Implementation details:**
1. Import Evennia's run_in_main_thread from evennia.server.sessionhandler
2. Create async wrapper that blocks until main thread completes
3. Create create_sandbox_from_project(project_id) function that:
   - Loads the BuildProject from database
   - Validates status is "approved"
   - Calls run_in_main_thread with build_sandbox_area
   - Returns (success: bool, result: dict) tuple
   - On success: updates project.sandbox_room_id and calls project.mark_built()

**Critical pattern for run_in_main_thread:**
```python
from evennia.server.sessionhandler import run_in_main_thread

def run_sync_in_main_thread(func, *args, **kwargs):
    """Run a function in Evennia's main thread and block for result."""
    import threading
    result = None
    error = None
    event = threading.Event()
    
    def wrapper():
        nonlocal result, error
        try:
            result = func(*args, **kwargs)
        except Exception as e:
            error = e
        finally:
            event.set()
    
    run_in_main_thread(wrapper)
    event.wait(timeout=30)  # 30 second timeout
    
    if error:
        raise error
    return result
```

**Error handling:**
- Catch ObjectDoesNotExist if project not found
- Validate status can transition to "built"
- Log all errors with project ID for debugging
- Return structured error dict on failure
  </action>
  <verify>
Check file exists and has required exports:
```bash
grep -E "(create_sandbox_from_project|run_in_main_thread)" beckonmu/web/builder/sandbox_bridge.py
grep "from evennia" beckonmu/web/builder/sandbox_bridge.py
```
  </verify>
  <done>
Bridge module exists with thread-safe wrapper and create_sandbox_from_project function that handles status validation and project updates.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sandbox_builder.py with room/exit creation logic</name>
  <files>beckonmu/web/builder/sandbox_builder.py</files>
  <action>
Create the builder module that creates actual Evennia objects from map_data.

**Implementation details:**

1. Import Evennia's create_object from evennia.utils.create
2. Import Room and Exit typeclasses from beckonmu.typeclasses
3. Import evennia.search_object for lookups

4. Create build_sandbox_area(project_id, map_data) function:
   - Creates sandbox container room as entry point
   - Creates all rooms from map_data["rooms"]
   - Creates all exits from map_data["exits"]
   - Returns dict with {sandbox_room_id, room_count, exit_count, room_map}

5. Room creation (per room in map_data["rooms"]):
   ```python
   room = create_object(
       typeclass="beckonmu.typeclasses.rooms.Room",
       key=room_data["name"],
       aliases=[f"_bld_{project_id}_{room_id}"],
       location=None,  # Rooms have no location
   )
   room.db.desc = room_data.get("description", "")
   
   # V5 attributes
   v5 = room_data.get("v5", {})
   if v5.get("location_type"):
       room.db.location_type = v5["location_type"]
   # ... etc for day_night, danger_level, hunting_modifier, territory_owner
   
   # Haven ratings
   if v5.get("location_type") == "haven" and v5.get("haven_ratings"):
       haven = v5["haven_ratings"]
       room.db.haven_security = haven.get("security", 0)
       # ... etc
   
   # Tags for tracking
   room.tags.add("web_builder")
   room.tags.add(f"project_{project_id}")
   room.tags.add("sandbox")
   ```

6. Exit creation (per exit in map_data["exits"]):
   ```python
   # Look up source/target rooms by alias
   source_alias = f"_bld_{project_id}_{exit_data['source']}"
   target_alias = f"_bld_{project_id}_{exit_data['target']}"
   sources = search_object(source_alias)
   targets = search_object(target_alias)
   
   if sources and targets:
       exit_obj = create_object(
           typeclass="beckonmu.typeclasses.exits.Exit",
           key=exit_data["name"],
           aliases=exit_data.get("aliases", []),
           location=sources[0],
           destination=targets[0],
       )
       if exit_data.get("description"):
           exit_obj.db.desc = exit_data["description"]
   ```

7. Track ID mapping:
   - Maintain dict mapping web room_id -> Evennia room object
   - Return this mapping for potential future use

**Error handling:**
- If room creation fails, continue with others but log error
- If exit references missing room, skip exit and log warning
- Return partial success with counts of what was created
  </action>
  <verify>
Check file exists and has required structure:
```bash
grep -E "(build_sandbox_area|create_object|search_object)" beckonmu/web/builder/sandbox_builder.py
grep "beckonmu.typeclasses" beckonmu/web/builder/sandbox_builder.py
grep "web_builder" beckonmu/web/builder/sandbox_builder.py
```
  </verify>
  <done>
Builder module exists with build_sandbox_area function that creates rooms with V5 attributes, exits with proper destinations, and tags everything for tracking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add BuildSandboxView API endpoint and wire to approval flow</name>
  <files>beckonmu/web/builder/views.py, beckonmu/web/builder/urls.py</files>
  <action>
Create the API endpoint that triggers sandbox building and wire it into the approval flow.

**In views.py:**

1. Import from sandbox_bridge:
   ```python
   from .sandbox_bridge import create_sandbox_from_project
   ```

2. Create BuildSandboxView class:
   ```python
   class BuildSandboxView(StaffRequiredMixin, View):
       """Build approved project to sandbox."""
       
       def post(self, request, pk, *args, **kwargs):
           project = get_object_or_404(BuildProject, pk=pk)
           
           # Check project is approved
           if project.status != "approved":
               return JsonResponse(
                   {"status": "error", "error": f"Project must be approved (current: {project.status})"},
                   status=400
               )
           
           # Check if already built
           if project.sandbox_room_id:
               return JsonResponse(
                   {"status": "error", "error": "Sandbox already exists", "sandbox_id": project.sandbox_room_id},
                   status=400
               )
           
           # Trigger sandbox creation
           success, result = create_sandbox_from_project(pk)
           
           if success:
               return JsonResponse({
                   "status": "success",
                   "message": "Sandbox created successfully",
                   "sandbox_id": result["sandbox_room_id"],
                   "room_count": result["room_count"],
                   "exit_count": result["exit_count"],
                   "project": {
                       "id": project.id,
                       "name": project.name,
                       "status": project.status,
                   }
               })
           else:
               return JsonResponse(
                   {"status": "error", "error": result.get("error", "Unknown error")},
                   status=500
               )
   ```

3. Modify ApproveRejectProjectView to optionally auto-build:
   - Add optional "build_sandbox" boolean to approval request body
   - If true and approval succeeds, call create_sandbox_from_project
   - Return sandbox info in success response if built

**In urls.py:**

Add URL pattern:
```python
path("api/build/<int:pk>/build-sandbox/", views.BuildSandboxView.as_view(), name="build-sandbox"),
```

**Update existing BuildProjectView:**
- Modify the existing BuildProjectView.post() to use new sandbox_bridge instead of returning "manual_required"
- Or deprecate it in favor of BuildSandboxView
  </action>
  <verify>
Check endpoint exists and is wired:
```bash
grep -E "(BuildSandboxView|build-sandbox)" beckonmu/web/builder/views.py beckonmu/web/builder/urls.py
grep "create_sandbox_from_project" beckonmu/web/builder/views.py
```
  </verify>
  <done>
BuildSandboxView API endpoint exists at POST /builder/api/build/{id}/build-sandbox/, validates project status, calls bridge, and returns sandbox details on success.
  </done>
</task>

</tasks>

<verification>
- [ ] sandbox_bridge.py has thread-safe run_in_main_thread wrapper
- [ ] sandbox_builder.py creates rooms with all V5 attributes
- [ ] sandbox_builder.py creates exits connecting rooms bidirectionally
- [ ] All created objects tagged with web_builder, project_{id}, sandbox
- [ ] BuildSandboxView validates project is "approved" before building
- [ ] BuildSandboxView returns sandbox_room_id on success
- [ ] Project status transitions to "built" after successful creation
- [ ] URL pattern added for build-sandbox endpoint
</verification>

<success_criteria>
1. POST /builder/api/build/{id}/build-sandbox/ creates sandbox for approved projects
2. Created rooms have correct names, descriptions, and V5 attributes
3. Created exits connect rooms matching web map layout
4. BuildProject.sandbox_room_id is populated with entry room ID
5. Project status changes from "approved" to "built"
6. All rooms tagged for identification and cleanup
</success_criteria>

<output>
After completion, create `.planning/phases/05-sandbox-building/05-01-SUMMARY.md`
</output>
