---
phase: 05-sandbox-building
plan: 02
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - beckonmu/commands/builder/sandbox.py
  - beckonmu/commands/default_cmdsets.py
  - beckonmu/web/builder/sandbox_cleanup.py
  - beckonmu/web/builder/views.py
  - beckonmu/typeclasses/rooms.py
autonomous: true

must_haves:
  truths:
    - "Sandbox rooms have special lock that prevents regular players from entering"
    - "Builder can use @goto_sandbox command to teleport to their sandbox entry room"
    - "Builder can walk through sandbox rooms and test exits normally"
    - "Staff can use @cleanup_sandbox command to delete all rooms/exits for a project"
    - "Cleanup removes all objects tagged with the project_id"
    - "BuildProject status resets to 'approved' after cleanup"
    - "BuildProject.sandbox_room_id is cleared after cleanup"
  artifacts:
    - path: "beckonmu/commands/builder/sandbox.py"
      provides: "In-game commands for sandbox navigation and cleanup"
      exports: ["CmdGotoSandbox", "CmdCleanupSandbox", "CmdListSandboxes"]
    - path: "beckonmu/web/builder/sandbox_cleanup.py"
      provides: "Programmatic sandbox cleanup from web context"
      exports: ["cleanup_sandbox_for_project"]
    - path: "beckonmu/typeclasses/rooms.py"
      provides: "Sandbox room lock override"
      contains: "sandbox access lock check"
  key_links:
    - from: "CmdGotoSandbox"
      to: "BuildProject.sandbox_room_id"
      via: "Database lookup and @tel command"
      pattern: "search_object.*sandbox_room_id"
    - from: "CmdCleanupSandbox"
      to: "sandbox_cleanup.cleanup_sandbox_for_project"
      via: "Direct function call"
      pattern: "cleanup_sandbox_for_project\(project_id\)"
    - from: "sandbox_cleanup"
      to: "evennia.search_object"
      via: "Tag-based object lookup"
      pattern: "search_object.*tag=.*project_"
    - from: "views.py"
      to: "sandbox_cleanup.cleanup_sandbox_for_project"
      via: "CleanupSandboxView API endpoint"
      pattern: "cleanup_sandbox_for_project.*project.id"
---

<objective>
Implement sandbox isolation, builder walkthrough capability, and cleanup system.

Purpose: Ensure sandbox areas are truly isolated from regular players while allowing builders to test their creations, and provide clean teardown when testing is complete.
Output: Complete sandbox lifecycle management with in-game commands and web API for cleanup.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-sandbox-building/05-01-SUMMARY.md

**From Phase 5 Requirements:**
- BLDW-05: Builder can walk through sandbox to test their build in-game
- BLDW-06: Sandbox cleanup deletes all sandbox rooms/exits tagged to a project

**Key Prior Decisions:**
- Sandbox rooms tagged with: web_builder, project_{id}, sandbox
- BuildProject.sandbox_room_id stores entry room database ID
- Status transitions: built â†’ approved (for cleanup)
- Staff permissions required for cleanup (builder can cleanup their own)

**Evennia Lock System:**
- Rooms have default locks preventing puppet/pickup
- Can add custom "traverse" lock to control who can enter
- Lock string format: "traverse:perm(Builder) or tag(project_{id})"

**Room Class Context:**
- Current Room class in typeclasses/rooms.py has display methods
- Can override access() or add custom lock functions
- ObjectParent mixin affects all game objects

**Command System:**
- Commands live in beckonmu/commands/
- Added to cmdsets in default_cmdsets.py
- Builder commands typically in builder/ subdirectory
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sandbox.py commands for navigation and cleanup</name>
  <files>beckonmu/commands/builder/sandbox.py</files>
  <action>
Create in-game commands for sandbox navigation and management.

**File: beckonmu/commands/builder/sandbox.py**

1. **CmdGotoSandbox** - Teleport builder to their sandbox:
   ```python
   from evennia.commands.command import Command
   from evennia.utils import search
   from beckonmu.web.builder.models import BuildProject
   
   class CmdGotoSandbox(Command):
       key = "@goto_sandbox"
       aliases = ["@gsb"]
       locks = "cmd:perm(Builder)"
       help_category = "Building"
       
       def func(self):
           if not self.args:
               # List user's sandboxes
               projects = BuildProject.objects.filter(
                   user=self.caller.account,
                   sandbox_room_id__isnull=False
               )
               if not projects:
                   self.caller.msg("You have no active sandboxes.")
                   return
               
               msg = "Your sandboxes:|/"
               for p in projects:
                   msg += f"  {p.name} (ID: {p.id})|/"
               msg += "|/Usage: @goto_sandbox <project_id>"
               self.caller.msg(msg)
               return
           
           try:
               project_id = int(self.args.strip())
               project = BuildProject.objects.get(
                   id=project_id,
                   user=self.caller.account,
                   sandbox_room_id__isnull=False
               )
           except (ValueError, BuildProject.DoesNotExist):
               self.caller.msg("Sandbox not found or you don't have access.")
               return
           
           # Find the sandbox entry room
           rooms = search.search_object(
               f"_bld_{project.id}_",  # Find any room in project
               typeclass="beckonmu.typeclasses.rooms.Room"
           )
           if rooms:
               self.caller.move_to(rooms[0])
               self.caller.msg(f"Teleported to sandbox: {project.name}")
           else:
               self.caller.msg("Sandbox rooms not found. May need cleanup.")
   ```

2. **CmdListSandboxes** - Staff command to list all sandboxes:
   ```python
   class CmdListSandboxes(Command):
       key = "@list_sandboxes"
       aliases = ["@lsb"]
       locks = "cmd:perm(Admin)"
       help_category = "Admin"
       
       def func(self):
           projects = BuildProject.objects.filter(
               sandbox_room_id__isnull=False
           ).select_related('user')
           
           if not projects:
               self.caller.msg("No active sandboxes.")
               return
           
           msg = "Active sandboxes:|/"
           msg += "-" * 50 + "|/"
           for p in projects:
               msg += f"ID: {p.id} | {p.name} | Builder: {p.user.username}|/"
           self.caller.msg(msg)
   ```

3. **CmdCleanupSandbox** - Delete sandbox rooms:
   ```python
   class CmdCleanupSandbox(Command):
       key = "@cleanup_sandbox"
       aliases = ["@csb"]
       locks = "cmd:perm(Builder)"
       help_category = "Building"
       
       def func(self):
           if not self.args:
               self.caller.msg("Usage: @cleanup_sandbox <project_id>")
               return
           
           try:
               project_id = int(self.args.strip())
               project = BuildProject.objects.get(id=project_id)
           except (ValueError, BuildProject.DoesNotExist):
               self.caller.msg("Project not found.")
               return
           
           # Permission check: staff or owner
           if not (self.caller.check_permstring("Admin") or 
                   project.user == self.caller.account):
               self.caller.msg("You don't have permission to cleanup this sandbox.")
               return
           
           if not project.sandbox_room_id:
               self.caller.msg("This project has no active sandbox.")
               return
           
           # Import and call cleanup
           from beckonmu.web.builder.sandbox_cleanup import cleanup_sandbox_for_project
           success, result = cleanup_sandbox_for_project(project_id)
           
           if success:
               self.caller.msg(f"Sandbox cleaned: {result['deleted_rooms']} rooms, "
                              f"{result['deleted_exits']} exits deleted.")
           else:
               self.caller.msg(f"Cleanup failed: {result.get('error', 'Unknown error')}")
   ```
  </action>
  <verify>
Check file exists with all three commands:
```bash
grep -E "(CmdGotoSandbox|CmdListSandboxes|CmdCleanupSandbox)" beckonmu/commands/builder/sandbox.py
grep "from beckonmu.web.builder" beckonmu/commands/builder/sandbox.py
```
  </verify>
  <done>
sandbox.py exists with three commands for navigation, listing, and cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sandbox_cleanup.py for programmatic cleanup</name>
  <files>beckonmu/web/builder/sandbox_cleanup.py</files>
  <action>
Create cleanup module that can be called from web or command context.

**File: beckonmu/web/builder/sandbox_cleanup.py**

```python
"""
Sandbox cleanup utilities for deleting all rooms/exits created for a project.
Can be called from web API or in-game commands.
"""
from evennia.utils import search
from evennia.server.sessionhandler import run_in_main_thread
import threading


def _do_cleanup_in_main_thread(project_id):
    """
    Actually perform cleanup in Evennia's main thread.
    Returns (success, result_dict).
    """
    try:
        from beckonmu.web.builder.models import BuildProject
        
        # Find all objects tagged with this project
        project_tag = f"project_{project_id}"
        
        # Search for rooms
        rooms = search.search_object(
            "",
            typeclass="beckonmu.typeclasses.rooms.Room",
            tags=[project_tag]
        )
        
        # Search for exits
        exits = search.search_object(
            "",
            typeclass="beckonmu.typeclasses.exits.Exit",
            tags=[project_tag]
        )
        
        # Search for objects
        objects = search.search_object(
            "",
            tags=[project_tag]
        )
        # Filter out rooms and exits (we already counted them)
        objects = [o for o in objects if o not in rooms and o not in exits]
        
        deleted_counts = {
            'rooms': 0,
            'exits': 0,
            'objects': 0,
            'errors': []
        }
        
        # Delete exits first (they reference rooms)
        for exit_obj in list(exits):
            try:
                exit_obj.delete()
                deleted_counts['exits'] += 1
            except Exception as e:
                deleted_counts['errors'].append(f"Exit {exit_obj.id}: {e}")
        
        # Delete objects
        for obj in list(objects):
            try:
                obj.delete()
                deleted_counts['objects'] += 1
            except Exception as e:
                deleted_counts['errors'].append(f"Object {obj.id}: {e}")
        
        # Delete rooms last
        for room in list(rooms):
            try:
                room.delete()
                deleted_counts['rooms'] += 1
            except Exception as e:
                deleted_counts['errors'].append(f"Room {room.id}: {e}")
        
        return True, deleted_counts
        
    except Exception as e:
        return False, {'error': str(e)}


def cleanup_sandbox_for_project(project_id):
    """
    Clean up all sandbox objects for a project.
    
    Args:
        project_id: BuildProject ID
        
    Returns:
        (success: bool, result: dict)
        result contains: deleted_rooms, deleted_exits, deleted_objects, errors
    """
    from beckonmu.web.builder.models import BuildProject
    
    try:
        project = BuildProject.objects.get(id=project_id)
    except BuildProject.DoesNotExist:
        return False, {'error': 'Project not found'}
    
    if not project.sandbox_room_id:
        return False, {'error': 'Project has no active sandbox'}
    
    # Run in main thread
    result = None
    error = None
    event = threading.Event()
    
    def wrapper():
        nonlocal result, error
        try:
            success, result = _do_cleanup_in_main_thread(project_id)
            if not success:
                error = result.get('error')
        except Exception as e:
            error = str(e)
        finally:
            event.set()
    
    run_in_main_thread(wrapper)
    event.wait(timeout=30)
    
    if error:
        return False, {'error': error}
    
    # Update project status
    project.sandbox_room_id = None
    project.save(update_fields=['sandbox_room_id'])
    
    # Reset status from 'built' to 'approved' if needed
    if project.status == 'built':
        # We can't use can_transition_to because built -> approved is valid
        # but mark_built() only goes forward. Direct update:
        project.status = 'approved'
        project.save(update_fields=['status'])
    
    return True, {
        'deleted_rooms': result.get('rooms', 0),
        'deleted_exits': result.get('exits', 0),
        'deleted_objects': result.get('objects', 0),
        'errors': result.get('errors', [])
    }
```
  </action>
  <verify>
Check file exists with required function:
```bash
grep "def cleanup_sandbox_for_project" beckonmu/web/builder/sandbox_cleanup.py
grep "run_in_main_thread" beckonmu/web/builder/sandbox_cleanup.py
grep "search_object" beckonmu/web/builder/sandbox_cleanup.py
```
  </verify>
  <done>
Cleanup module exists with thread-safe deletion that updates project status and clears sandbox_room_id.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add sandbox isolation locks and wire commands to cmdset</name>
  <files>beckonmu/typeclasses/rooms.py, beckonmu/commands/default_cmdsets.py</files>
  <action>
Add sandbox isolation and register commands.

**In typeclasses/rooms.py:**

Add access method override for sandbox isolation:
```python
def access(self, accessing_obj, access_type='view', default=False, **kwargs):
    """
    Override access to implement sandbox isolation.
    Sandbox rooms can only be entered by:
    - The builder who owns the sandbox
    - Staff members
    """
    if access_type == 'traverse' and self.tags.get('sandbox'):
        # Check if accessing_obj is the sandbox owner
        # Sandbox rooms are tagged with project_{id}
        project_tags = [t for t in self.tags.all() if t.startswith('project_')]
        if project_tags:
            from beckonmu.web.builder.models import BuildProject
            try:
                project_id = int(project_tags[0].split('_')[1])
                project = BuildProject.objects.get(id=project_id)
                
                # Allow if owner or staff
                if (hasattr(accessing_obj, 'account') and 
                    accessing_obj.account == project.user):
                    return True
                if accessing_obj.check_permstring('Admin'):
                    return True
                    
                # Deny regular players
                return False
            except (ValueError, BuildProject.DoesNotExist):
                pass
    
    # Default access for non-sandbox or other access types
    return super().access(accessing_obj, access_type, default, **kwargs)
```

**In commands/default_cmdsets.py:**

Add sandbox commands to the appropriate cmdset:
```python
# Import at top
from beckonmu.commands.builder.sandbox import (
    CmdGotoSandbox, 
    CmdListSandboxes, 
    CmdCleanupSandbox
)

# Add to BuilderCmdSet.at_cmdset_creation():
self.add(CmdGotoSandbox)
self.add(CmdCleanupSandbox)

# Add to AdminCmdSet.at_cmdset_creation():
self.add(CmdListSandboxes)
```

**Add CleanupSandboxView to views.py:**

```python
class CleanupSandboxView(StaffRequiredMixin, View):
    """Clean up a sandbox via API."""
    
    def post(self, request, pk, *args, **kwargs):
        from .sandbox_cleanup import cleanup_sandbox_for_project
        
        project = get_object_or_404(BuildProject, pk=pk)
        
        # Permission check
        if not (request.user.is_staff or project.user == request.user):
            return JsonResponse(
                {"status": "error", "error": "Not authorized"}, 
                status=403
            )
        
        if not project.sandbox_room_id:
            return JsonResponse(
                {"status": "error", "error": "No active sandbox"}, 
                status=400
            )
        
        success, result = cleanup_sandbox_for_project(pk)
        
        if success:
            return JsonResponse({
                "status": "success",
                "message": "Sandbox cleaned up",
                "deleted": {
                    "rooms": result['deleted_rooms'],
                    "exits": result['deleted_exits'],
                    "objects": result['deleted_objects']
                }
            })
        else:
            return JsonResponse(
                {"status": "error", "error": result.get('error', 'Unknown')},
                status=500
            )
```

**Add URL pattern in urls.py:**
```python
path("api/build/<int:pk>/cleanup/", views.CleanupSandboxView.as_view(), name="cleanup-sandbox"),
```
  </action>
  <verify>
Check all integrations:
```bash
grep "access.*traverse.*sandbox" beckonmu/typeclasses/rooms.py
grep -E "(CmdGotoSandbox|CmdCleanupSandbox|CmdListSandboxes)" beckonmu/commands/default_cmdsets.py
grep "CleanupSandboxView" beckonmu/web/builder/views.py beckonmu/web/builder/urls.py
```
  </verify>
  <done>
Room access override blocks regular players from sandbox, commands registered in cmdsets, and CleanupSandboxView API endpoint exists.
  </done>
</task>

</tasks>

<verification>
- [ ] @goto_sandbox command teleports builder to their sandbox
- [ ] @list_sandboxes shows all active sandboxes (staff only)
- [ ] @cleanup_sandbox deletes rooms/exits and resets project
- [ ] Regular players cannot enter sandbox rooms
- [ ] POST /builder/api/build/{id}/cleanup/ works via web API
- [ ] Project status resets to 'approved' after cleanup
- [ ] sandbox_room_id cleared after cleanup
- [ ] All three commands added to appropriate cmdsets
</verification>

<success_criteria>
1. Builder can use @goto_sandbox to teleport to their sandbox
2. Regular players are blocked from entering sandbox rooms
3. Staff can list all sandboxes with @list_sandboxes
4. @cleanup_sandbox removes all rooms/exits and updates project status
5. Web API endpoint for cleanup works and requires proper permissions
6. Sandbox rooms maintain isolation even after server restart
</success_criteria>

<output>
After completion, create `.planning/phases/05-sandbox-building/05-02-SUMMARY.md`
</output>
