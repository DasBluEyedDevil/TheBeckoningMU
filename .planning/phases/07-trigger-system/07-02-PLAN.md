---
phase: 07-trigger-system
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - beckonmu/typeclasses/scripts.py
  - beckonmu/web/builder/trigger_scripts.py
  - beckonmu/web/builder/sandbox_builder.py
autonomous: true

must_haves:
  truths:
    - "Timed triggers fire at their configured interval (e.g., every 5 minutes)"
    - "Timed triggers are attached to rooms as Evennia Scripts"
    - "When a sandbox is built, timed triggers are created as Script objects"
    - "When a sandbox is cleaned up, timed trigger scripts are stopped and deleted"
  artifacts:
    - path: "beckonmu/typeclasses/scripts.py"
      provides: "RoomTriggerScript typeclass for timed triggers"
      contains: "class RoomTriggerScript with at_repeat hook"
    - path: "beckonmu/web/builder/trigger_scripts.py"
      provides: "Script management for room triggers"
      exports: ["create_timed_trigger", "delete_timed_triggers_for_room"]
    - path: "beckonmu/web/builder/sandbox_builder.py"
      provides: "Integration with sandbox building"
      changes: "Creates timed trigger scripts during room creation"
  key_links:
    - from: "beckonmu/web/builder/trigger_scripts.py"
      to: "beckonmu/typeclasses/scripts.py"
      via: "create_script with obj=room"
      pattern: "create_script.*RoomTriggerScript"
    - from: "beckonmu/web/builder/sandbox_builder.py"
      to: "beckonmu/web/builder/trigger_scripts.py"
      via: "import and call create_timed_trigger"
      pattern: "from.*trigger_scripts import"

user_setup: []
---

<objective>
Implement timed triggers using Evennia Scripts that fire at configurable intervals.

Purpose: Enable rooms to have atmospheric events, weather, and periodic effects.
Output: Working timed trigger system integrated with sandbox building and cleanup.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-trigger-system/07-01-SUMMARY.md

**Prior Plan Context (07-01):**
Entry/exit trigger engine exists in `beckonmu/web/builder/trigger_engine.py` with whitelisted actions. Room typeclass has `at_object_receive` and `at_object_leave` hooks.

**Evennia Scripts (from typeclasses/scripts.py):**
Scripts are database-persistent objects with timer capabilities:
- `interval` - how often to fire (seconds)
- `at_repeat()` - called every interval
- `obj` - optional object this script acts on (will be the room)
- Scripts are created with `evennia.create_script()`

**Sandbox Builder (from sandbox_builder.py):**
Creates rooms from map_data. Currently stores triggers in `room.db.triggers` but doesn't create Script objects for timed triggers.

**Sandbox Cleanup (from sandbox_cleanup.py):**
Deletes sandbox rooms. Must also clean up any trigger scripts attached to those rooms.
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoomTriggerScript typeclass</name>
  <files>beckonmu/typeclasses/scripts.py</files>
  <action>
Modify `beckonmu/typeclasses/scripts.py` to add `RoomTriggerScript` class:

```python
class RoomTriggerScript(DefaultScript):
    """
    Script for timed room triggers.
    
    Attached to a room, fires at configured intervals to execute
    trigger actions like atmospheric messages or weather effects.
    """
    
    # Script properties
    desc = "Timed trigger script for room effects"
    
    # Default interval (can be overridden per instance)
    interval = 300  # 5 minutes default
    
    # Start immediately, don't wait for first interval
    start_delay = False
    
    # Run forever (0 = infinite repeats)
    repeats = 0
    
    # Survive server restarts
    persistent = True
    
    def at_script_creation(self):
        """
        Called when script is first created.
        Store trigger configuration in db attributes.
        """
        # These will be set by trigger_scripts.py when creating
        self.db.trigger_id = None
        self.db.trigger_action = None
        self.db.trigger_parameters = {}
    
    def at_start(self):
        """Called when script starts (after server reload too)."""
        pass
    
    def at_repeat(self):
        """
        Called every self.interval seconds.
        Execute the configured trigger action.
        """
        if not self.obj:
            # No room attached, stop the script
            self.stop()
            return
        
        # Import here to avoid circular imports
        from beckonmu.web.builder.trigger_engine import execute_triggers
        
        # Execute as a "timed" trigger type
        # The engine will filter by trigger_id to find this specific trigger
        execute_triggers(
            room=self.obj,
            trigger_type="timed",
            character=None,  # Timed triggers don't have a character
            trigger_id=self.db.trigger_id
        )
    
    def at_stop(self):
        """Called when script is stopped."""
        pass
    
    def is_valid(self):
        """
        Check if script should continue running.
        Stop if room no longer exists or trigger is disabled.
        """
        if not self.obj:
            return False
        
        # Check if trigger still exists and is enabled
        triggers = self.obj.db.triggers or []
        for trigger in triggers:
            if trigger.get("id") == self.db.trigger_id:
                return trigger.get("enabled", True)
        
        # Trigger not found, stop the script
        return False
```

**Note:** Need to update `execute_triggers` in trigger_engine.py to accept optional `trigger_id` parameter for filtering.
  </action>
  <verify>
Check RoomTriggerScript class exists:
```bash
grep -n "class RoomTriggerScript" beckonmu/typeclasses/scripts.py
grep -n "def at_repeat\|def is_valid" beckonmu/typeclasses/scripts.py
```
  </verify>
  <done>
RoomTriggerScript typeclass exists with at_repeat hook that calls execute_triggers, is_valid checks room and trigger existence.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create trigger script management module</name>
  <files>beckonmu/web/builder/trigger_scripts.py</files>
  <action>
Create `beckonmu/web/builder/trigger_scripts.py` with script management functions:

```python
"""
Trigger script management for timed room triggers.

Handles creation, deletion, and lifecycle of Evennia Scripts
attached to rooms for timed trigger execution.
"""

import logging
from typing import List, Dict, Any, Optional

from evennia.utils.create import create_script
from evennia.utils.search import search_script

logger = logging.getLogger(__name__)


def create_timed_trigger(room, trigger_data: Dict[str, Any]) -> Optional[Any]:
    """
    Create a timed trigger script attached to a room.
    
    Args:
        room: The Evennia room object to attach trigger to
        trigger_data: Trigger configuration dict with:
            - id: unique trigger identifier
            - interval: seconds between firings (default 300)
            - action: action name (from ACTION_REGISTRY)
            - parameters: dict of action parameters
            - enabled: bool (default True)
    
    Returns:
        The created Script object, or None if creation failed
    """
    trigger_id = trigger_data.get("id")
    if not trigger_id:
        logger.error("Cannot create timed trigger without id")
        return None
    
    # Check if script already exists for this trigger
    existing = search_script(f"trigger_{trigger_id}")
    if existing:
        logger.warning(f"Timed trigger {trigger_id} already exists, skipping")
        return existing[0]
    
    interval = trigger_data.get("interval", 300)
    if interval < 10:
        logger.warning(f"Trigger {trigger_id} interval {interval}s too short, using 10s minimum")
        interval = 10
    
    try:
        script = create_script(
            typeclass="beckonmu.typeclasses.scripts.RoomTriggerScript",
            key=f"trigger_{trigger_id}",
            obj=room,
            interval=interval,
            persistent=True,
            repeats=0,  # Infinite
            start_delay=False,
        )
        
        # Store trigger configuration
        script.db.trigger_id = trigger_id
        script.db.trigger_action = trigger_data.get("action")
        script.db.trigger_parameters = trigger_data.get("parameters", {})
        
        logger.info(f"Created timed trigger {trigger_id} on room {room.id} (interval: {interval}s)")
        return script
        
    except Exception as e:
        logger.exception(f"Failed to create timed trigger {trigger_id}: {e}")
        return None


def delete_timed_trigger(trigger_id: str) -> bool:
    """
    Delete a specific timed trigger script by trigger ID.
    
    Args:
        trigger_id: The unique trigger identifier
    
    Returns:
        True if deleted or didn't exist, False on error
    """
    try:
        scripts = search_script(f"trigger_{trigger_id}")
        for script in scripts:
            script.stop()
            script.delete()
            logger.info(f"Deleted timed trigger {trigger_id}")
        return True
    except Exception as e:
        logger.exception(f"Failed to delete timed trigger {trigger_id}: {e}")
        return False


def delete_timed_triggers_for_room(room) -> int:
    """
    Delete all timed trigger scripts attached to a room.
    
    Args:
        room: The Evennia room object
    
    Returns:
        Number of scripts deleted
    """
    count = 0
    try:
        # Find scripts where obj is this room
        from evennia.scripts.models import ScriptDB
        scripts = ScriptDB.objects.filter(obj=room)
        
        for script in scripts:
            # Only delete our trigger scripts
            if (hasattr(script, 'db') and 
                hasattr(script.db, 'trigger_id') and 
                script.db.trigger_id):
                script.stop()
                script.delete()
                count += 1
        
        if count > 0:
            logger.info(f"Deleted {count} timed triggers for room {room.id}")
        return count
        
    except Exception as e:
        logger.exception(f"Failed to delete timed triggers for room {room.id}: {e}")
        return count


def sync_timed_triggers_for_room(room) -> Dict[str, Any]:
    """
    Synchronize timed triggers for a room based on room.db.triggers.
    
    Creates scripts for new timed triggers, deletes scripts for
    removed triggers, updates changed triggers.
    
    Args:
        room: The Evennia room object
    
    Returns:
        Dict with created, deleted, updated counts
    """
    results = {"created": 0, "deleted": 0, "updated": 0, "errors": []}
    
    try:
        triggers = room.db.triggers or []
        timed_trigger_ids = set()
        
        # Process current timed triggers
        for trigger in triggers:
            if trigger.get("type") != "timed":
                continue
            if not trigger.get("enabled", True):
                continue
            
            trigger_id = trigger.get("id")
            if not trigger_id:
                continue
            
            timed_trigger_ids.add(trigger_id)
            
            # Check if script exists
            existing = search_script(f"trigger_{trigger_id}")
            if not existing:
                # Create new script
                if create_timed_trigger(room, trigger):
                    results["created"] += 1
                else:
                    results["errors"].append(f"Failed to create {trigger_id}")
        
        # Find and delete orphaned scripts
        from evennia.scripts.models import ScriptDB
        existing_scripts = ScriptDB.objects.filter(obj=room)
        
        for script in existing_scripts:
            if (hasattr(script, 'db') and 
                hasattr(script.db, 'trigger_id') and 
                script.db.trigger_id and
                script.db.trigger_id not in timed_trigger_ids):
                script.stop()
                script.delete()
                results["deleted"] += 1
        
        return results
        
    except Exception as e:
        logger.exception(f"Failed to sync timed triggers for room {room.id}: {e}")
        results["errors"].append(str(e))
        return results
```
  </action>
  <verify>
Check module exists with key functions:
```bash
grep -n "def create_timed_trigger\|def delete_timed_trigger\|def sync_timed_triggers" beckonmu/web/builder/trigger_scripts.py
```
  </verify>
  <done>
trigger_scripts.py exists with create_timed_trigger, delete_timed_triggers_for_room, and sync_timed_triggers_for_room functions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate timed triggers into sandbox building</name>
  <files>beckonmu/web/builder/sandbox_builder.py</files>
  <action>
Modify `beckonmu/web/builder/sandbox_builder.py` to create timed trigger scripts:

1. Add import at top:
```python
from .trigger_scripts import create_timed_trigger, delete_timed_triggers_for_room
```

2. In `build_sandbox_area()`, after creating each room (around line 109 where triggers are stored),
   add code to create timed trigger scripts:

```python
# After: room.db.triggers = triggers (line 109)

# Create timed trigger scripts for this room
for trigger in triggers:
    if trigger.get("type") == "timed" and trigger.get("enabled", True):
        create_timed_trigger(room, trigger)
```

3. Also need to update trigger_engine.py to support trigger_id filtering:
   In `execute_triggers()`, add optional `trigger_id` parameter and filter:

```python
def execute_triggers(room, trigger_type, character, trigger_id=None, **context):
    """
    Execute triggers of a specific type on a room.
    
    Args:
        room: The room object
        trigger_type: "entry", "exit", "timed", or "interaction"
        character: The character involved (None for timed triggers)
        trigger_id: Optional specific trigger ID to execute (for timed triggers)
        **context: Additional context (target_location for exits, etc.)
    """
    triggers = room.db.triggers or []
    
    for trigger in triggers:
        # Filter by trigger_id if specified
        if trigger_id and trigger.get("id") != trigger_id:
            continue
        
        # Filter by type and enabled status
        if trigger.get("type") != trigger_type:
            continue
        if not trigger.get("enabled", True):
            continue
        
        # ... rest of execution logic
```

4. Update `beckonmu/web/builder/sandbox_cleanup.py` to delete trigger scripts:
   Add import: `from .trigger_scripts import delete_timed_triggers_for_room`
   
   In the cleanup function, before deleting a room, call:
   ```python
   delete_timed_triggers_for_room(room)
   ```
  </action>
  <verify>
Check imports and function calls added:
```bash
grep -n "from.*trigger_scripts import\|create_timed_trigger\|delete_timed_triggers_for_room" beckonmu/web/builder/sandbox_builder.py
grep -n "trigger_id" beckonmu/web/builder/trigger_engine.py
```
  </verify>
  <done>
Sandbox builder creates timed trigger scripts during room creation, cleanup deletes trigger scripts, trigger engine supports trigger_id filtering.
  </done>
</task>

</tasks>

<verification>
**Automated checks:**
```bash
# Check all files exist
ls beckonmu/typeclasses/scripts.py
ls beckonmu/web/builder/trigger_scripts.py

# Check RoomTriggerScript exists
python -c "from beckonmu.typeclasses.scripts import RoomTriggerScript; print('RoomTriggerScript OK')"

# Check trigger_scripts imports
python -c "from beckonmu.web.builder.trigger_scripts import create_timed_trigger, delete_timed_triggers_for_room; print('trigger_scripts OK')"

# Check sandbox_builder has imports
grep -n "trigger_scripts" beckonmu/web/builder/sandbox_builder.py
```

**Manual verification:**
1. Create a room with a timed trigger (interval: 60 seconds)
2. Build sandbox - verify script is created
3. Wait for interval - trigger should fire
4. Cleanup sandbox - verify script is deleted
</verification>

<success_criteria>
- [ ] RoomTriggerScript typeclass exists with at_repeat hook
- [ ] RoomTriggerScript.is_valid() checks room and trigger existence
- [ ] trigger_scripts.py has create_timed_trigger function
- [ ] trigger_scripts.py has delete_timed_triggers_for_room function
- [ ] trigger_scripts.py has sync_timed_triggers_for_room function
- [ ] sandbox_builder.py creates timed trigger scripts during build
- [ ] sandbox_cleanup.py deletes timed trigger scripts during cleanup
- [ ] trigger_engine.py supports optional trigger_id filtering
- [ ] Minimum interval enforcement (10 seconds) prevents abuse
</success_criteria>

<output>
After completion, create `.planning/phases/07-trigger-system/07-02-SUMMARY.md`
</output>
