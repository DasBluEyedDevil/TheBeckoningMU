---
phase: 07-trigger-system
plan: 03
type: execute
wave: 3
depends_on: ["07-01", "07-02"]
files_modified:
  - beckonmu/web/builder/trigger_engine.py
  - beckonmu/web/builder/v5_conditions.py
  - beckonmu/web/builder/views.py
  - beckonmu/web/templates/builder/editor.html
  - beckonmu/web/builder/urls.py
autonomous: true

must_haves:
  truths:
    - "Builder can add/edit/delete triggers through the web builder UI"
    - "Trigger editor shows type selector (entry/exit/timed/interaction)"
    - "V5 conditions can check character hunger level, clan, and time-of-night"
    - "Only whitelisted actions appear in the action selector"
    - "Trigger data is validated before save (schema validation)"
  artifacts:
    - path: "beckonmu/web/builder/v5_conditions.py"
      provides: "V5-aware condition checking"
      exports: ["check_condition", "list_condition_types"]
    - path: "beckonmu/web/builder/views.py"
      provides: "API endpoints for trigger CRUD"
      exports: ["RoomTriggersAPI", "TriggerActionsAPI"]
    - path: "beckonmu/web/templates/builder/editor.html"
      provides: "Trigger editor UI in sidebar"
      contains: "Trigger form with type/action/condition/parameter fields"
  key_links:
    - from: "beckonmu/web/builder/trigger_engine.py"
      to: "beckonmu/web/builder/v5_conditions.py"
      via: "check_condition call before action execution"
      pattern: "if not check_condition.*skip"
    - from: "beckonmu/web/builder/views.py"
      to: "beckonmu/web/builder/trigger_engine.py"
      via: "validate_trigger for API validation"
      pattern: "validate_trigger.*request.data"

user_setup: []
---

<objective>
Build the trigger editor UI and V5-aware condition system for interaction triggers.

Purpose: Enable builders to create and configure triggers through the web interface with V5-specific conditions.
Output: Complete trigger editor with type selector, V5 conditions, and whitelisted actions.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-trigger-system/07-01-SUMMARY.md
@.planning/phases/07-trigger-system/07-02-SUMMARY.md

**Prior Plans Context (07-01, 07-02):**
- Entry/exit trigger engine exists with whitelisted actions
- Timed triggers use RoomTriggerScript typeclass
- trigger_engine.py has `execute_triggers()` and `validate_trigger()`
- trigger_actions.py has ACTION_REGISTRY with safe actions

**V5 Game State (from traits/models.py):**
- CharacterBio has splat (vampire, ghoul, etc.)
- CharacterTrait tracks hunger (for vampires)
- Room has db.location_type, db.danger_level, db.day_night

**Builder Editor (from web/templates/builder/editor.html):**
Existing editor has room properties panel, V5 settings panel. Need to add trigger editor panel.

**URL Structure (from web/builder/urls.py):**
API endpoints under `/builder/api/` path.

**Requirements (TRIG-04 to TRIG-07):**
- TRIG-04: Interaction triggers fire on specific player actions
- TRIG-05: Trigger editor UI in web builder
- TRIG-06: V5-aware conditions (hunger, clan, time-of-night)
- TRIG-07: Whitelisted actions only
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create V5 condition checking module</name>
  <files>beckonmu/web/builder/v5_conditions.py</files>
  <action>
Create `beckonmu/web/builder/v5_conditions.py` with V5-aware condition checking:

```python
"""
V5-aware condition checking for room triggers.

Conditions can check character state, room state, and game state
to determine if a trigger should fire.
"""

import logging
from typing import Dict, Any, Optional, List
from datetime import datetime

logger = logging.getLogger(__name__)


# Condition type definitions for UI
CONDITION_TYPES = {
    "character_clan": {
        "label": "Character Clan",
        "description": "Check if character is of a specific clan",
        "parameters": {
            "clan": {
                "type": "select",
                "options": ["brujah", "gangrel", "malkavian", "nosferatu", "toreador", "tremere", "ventrue", "caitiff", "thin_blood"],
                "required": True
            }
        }
    },
    "character_splat": {
        "label": "Character Type",
        "description": "Check if character is vampire, ghoul, etc.",
        "parameters": {
            "splat": {
                "type": "select",
                "options": ["vampire", "ghoul", "mortal", "hunter"],
                "required": True
            }
        }
    },
    "character_hunger": {
        "label": "Hunger Level",
        "description": "Check character's hunger level (vampires only)",
        "parameters": {
            "operator": {
                "type": "select",
                "options": ["eq", "lt", "lte", "gt", "gte"],
                "required": True
            },
            "value": {
                "type": "number",
                "min": 0,
                "max": 5,
                "required": True
            }
        }
    },
    "room_type": {
        "label": "Room Type",
        "description": "Check the room's V5 location type",
        "parameters": {
            "location_type": {
                "type": "select",
                "options": ["elysium", "haven", "rack", "neutral", "dangerous", "hunting_ground", "mystical", "street", "business"],
                "required": True
            }
        }
    },
    "time_of_day": {
        "label": "Time of Day",
        "description": "Check current in-game time",
        "parameters": {
            "time": {
                "type": "select",
                "options": ["day", "night"],
                "required": True
            }
        }
    },
    "room_danger": {
        "label": "Danger Level",
        "description": "Check room's danger rating",
        "parameters": {
            "operator": {
                "type": "select",
                "options": ["eq", "lt", "lte", "gt", "gte"],
                "required": True
            },
            "value": {
                "type": "number",
                "min": 0,
                "max": 5,
                "required": True
            }
        }
    },
    "probability": {
        "label": "Random Chance",
        "description": "Random chance for trigger to fire (percentage)",
        "parameters": {
            "chance": {
                "type": "number",
                "min": 1,
                "max": 100,
                "required": True
            }
        }
    }
}


def list_condition_types() -> Dict[str, Any]:
    """Return condition type definitions for UI rendering."""
    return CONDITION_TYPES


def check_condition(condition_type: str, parameters: Dict[str, Any], 
                   character=None, room=None) -> bool:
    """
    Check if a condition is met.
    
    Args:
        condition_type: The type of condition to check
        parameters: Condition-specific parameters
        character: The character to check (may be None for timed triggers)
        room: The room where trigger is firing
    
    Returns:
        True if condition is met, False otherwise
    """
    try:
        if condition_type == "character_clan":
            return _check_character_clan(character, parameters.get("clan"))
        
        elif condition_type == "character_splat":
            return _check_character_splat(character, parameters.get("splat"))
        
        elif condition_type == "character_hunger":
            return _check_character_hunger(
                character, 
                parameters.get("operator"),
                parameters.get("value")
            )
        
        elif condition_type == "room_type":
            return _check_room_type(room, parameters.get("location_type"))
        
        elif condition_type == "time_of_day":
            return _check_time_of_day(parameters.get("time"))
        
        elif condition_type == "room_danger":
            return _check_room_danger(
                room,
                parameters.get("operator"),
                parameters.get("value")
            )
        
        elif condition_type == "probability":
            return _check_probability(parameters.get("chance", 100))
        
        else:
            logger.warning(f"Unknown condition type: {condition_type}")
            return False
            
    except Exception as e:
        logger.exception(f"Error checking condition {condition_type}: {e}")
        return False


def _check_character_clan(character, clan: str) -> bool:
    """Check if character is of specified clan."""
    if not character or not clan:
        return False
    
    # Get clan from character's bio/traits
    try:
        from beckonmu.traits.models import CharacterBio
        bio = CharacterBio.objects.get(character_id=character.id)
        # Clan would be stored in traits or bio - adjust as needed
        # For now, check if character has clan in db attributes
        char_clan = character.db.clan or character.attributes.get("clan")
        return char_clan and char_clan.lower() == clan.lower()
    except Exception:
        return False


def _check_character_splat(character, splat: str) -> bool:
    """Check if character is of specified splat type."""
    if not character or not splat:
        return False
    
    try:
        from beckonmu.traits.models import CharacterBio
        bio = CharacterBio.objects.get(character_id=character.id)
        return bio.splat.lower() == splat.lower()
    except Exception:
        return False


def _check_character_hunger(character, operator: str, value: int) -> bool:
    """Check character's hunger level."""
    if not character:
        return False
    
    # Get hunger from character traits
    try:
        from beckonmu.traits.models import CharacterTrait, Trait
        hunger_trait = Trait.objects.get(name="Hunger")
        char_hunger = CharacterTrait.objects.get(
            character_id=character.id,
            trait=hunger_trait
        )
        hunger_value = char_hunger.rating
    except Exception:
        # Fall back to db attribute
        hunger_value = getattr(character.db, 'hunger', 0)
    
    return _compare(hunger_value, operator, value)


def _check_room_type(room, location_type: str) -> bool:
    """Check room's V5 location type."""
    if not room or not location_type:
        return False
    
    room_type = getattr(room.db, 'location_type', None)
    return room_type and room_type.lower() == location_type.lower()


def _check_time_of_day(time: str) -> bool:
    """Check current time of day."""
    # Simple implementation - could be enhanced with in-game time system
    hour = datetime.now().hour
    is_night = hour < 6 or hour >= 18
    
    if time == "night":
        return is_night
    elif time == "day":
        return not is_night
    return False


def _check_room_danger(room, operator: str, value: int) -> bool:
    """Check room's danger level."""
    if not room:
        return False
    
    danger = getattr(room.db, 'danger_level', 0)
    return _compare(danger, operator, value)


def _check_probability(chance: int) -> bool:
    """Random chance check."""
    import random
    return random.randint(1, 100) <= chance


def _compare(actual, operator: str, expected) -> bool:
    """Compare values with operator."""
    if operator == "eq":
        return actual == expected
    elif operator == "lt":
        return actual < expected
    elif operator == "lte":
        return actual <= expected
    elif operator == "gt":
        return actual > expected
    elif operator == "gte":
        return actual >= expected
    return False
```
  </action>
  <verify>
Check module exists with key functions:
```bash
grep -n "def check_condition\|def list_condition_types\|CONDITION_TYPES" beckonmu/web/builder/v5_conditions.py | head -20
```
  </verify>
  <done>
v5_conditions.py exists with check_condition function, CONDITION_TYPES dict with 7+ condition types, all condition checkers implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update trigger engine with condition support</name>
  <files>beckonmu/web/builder/trigger_engine.py</files>
  <action>
Update `beckonmu/web/builder/trigger_engine.py` to add condition checking:

1. Add import at top:
```python
from .v5_conditions import check_condition
```

2. Update `validate_trigger()` to validate conditions:
```python
def validate_trigger(trigger_data):
    """
    Validate trigger data structure.
    
    Returns:
        (is_valid, error_message) tuple
    """
    required = ["id", "type", "action"]
    for field in required:
        if field not in trigger_data:
            return False, f"Missing required field: {field}"
    
    # Validate trigger type
    valid_types = ["entry", "exit", "timed", "interaction"]
    if trigger_data["type"] not in valid_types:
        return False, f"Invalid trigger type: {trigger_data['type']}"
    
    # Validate action exists
    from .trigger_actions import ACTION_REGISTRY
    if trigger_data["action"] not in ACTION_REGISTRY:
        return False, f"Invalid action: {trigger_data['action']}"
    
    # Validate parameters is dict
    params = trigger_data.get("parameters", {})
    if not isinstance(params, dict):
        return False, "parameters must be a dictionary"
    
    # Validate conditions if present
    conditions = trigger_data.get("conditions", [])
    if conditions:
        if not isinstance(conditions, list):
            return False, "conditions must be a list"
        
        from .v5_conditions import list_condition_types
        valid_conditions = list_condition_types()
        
        for condition in conditions:
            if not isinstance(condition, dict):
                return False, "each condition must be a dictionary"
            if "type" not in condition:
                return False, "condition missing 'type' field"
            if condition["type"] not in valid_conditions:
                return False, f"invalid condition type: {condition['type']}"
    
    # Validate timed trigger has interval
    if trigger_data["type"] == "timed":
        interval = trigger_data.get("interval")
        if not interval or not isinstance(interval, int) or interval < 10:
            return False, "timed triggers must have interval >= 10 seconds"
    
    return True, None
```

3. Update `execute_triggers()` to check conditions:
```python
def execute_triggers(room, trigger_type, character, trigger_id=None, **context):
    """
    Execute triggers of a specific type on a room.
    """
    triggers = room.db.triggers or []
    
    for trigger in triggers:
        # Filter by trigger_id if specified
        if trigger_id and trigger.get("id") != trigger_id:
            continue
        
        # Filter by type and enabled status
        if trigger.get("type") != trigger_type:
            continue
        if not trigger.get("enabled", True):
            continue
        
        # Check conditions
        conditions = trigger.get("conditions", [])
        conditions_met = True
        for condition in conditions:
            if not check_condition(
                condition.get("type"),
                condition.get("parameters", {}),
                character=character,
                room=room
            ):
                conditions_met = False
                break
        
        if not conditions_met:
            continue
        
        # Execute the action
        action_name = trigger.get("action")
        parameters = trigger.get("parameters", {})
        
        try:
            if action_name in ACTION_REGISTRY:
                action_func = ACTION_REGISTRY[action_name]
                
                # Add character and room to parameters if action expects them
                action_params = parameters.copy()
                if character:
                    action_params.setdefault("character", character)
                action_params.setdefault("room", room)
                
                action_func(**action_params)
                logger.debug(f"Executed trigger {trigger.get('id')} action {action_name}")
            else:
                logger.warning(f"Unknown action: {action_name}")
        except Exception as e:
            logger.exception(f"Error executing trigger {trigger.get('id')}: {e}")
```
  </action>
  <verify>
Check condition import and validation:
```bash
grep -n "from.*v5_conditions import\|validate_trigger.*conditions" beckonmu/web/builder/trigger_engine.py
```
  </verify>
  <done>
trigger_engine validates conditions, checks conditions before executing actions, passes character and room to condition checker.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create trigger API endpoints</name>
  <files>beckonmu/web/builder/views.py</files>
  <action>
Add API endpoints to `beckonmu/web/builder/views.py` for trigger management:

1. Add imports at top:
```python
import json
from django.views import View
from .trigger_engine import validate_trigger
from .trigger_actions import ACTION_REGISTRY, list_actions
from .v5_conditions import list_condition_types
```

2. Add `RoomTriggersAPI` class:
```python
class RoomTriggersAPI(LoginRequiredMixin, View):
    """
    API for managing room triggers within a project.
    
    GET /builder/api/projects/<project_id>/rooms/<room_id>/triggers/
    POST /builder/api/projects/<project_id>/rooms/<room_id>/triggers/
    DELETE /builder/api/projects/<project_id>/rooms/<room_id>/triggers/<trigger_id>/
    """
    
    def get(self, request, project_id, room_id):
        """Get all triggers for a room."""
        try:
            project = BuildProject.objects.get(id=project_id, user=request.user)
            map_data = project.map_data or {}
            rooms = map_data.get("rooms", {})
            
            if room_id not in rooms:
                return JsonResponse({"error": "Room not found"}, status=404)
            
            room_data = rooms[room_id]
            triggers = room_data.get("triggers", [])
            
            return JsonResponse({"triggers": triggers})
        except BuildProject.DoesNotExist:
            return JsonResponse({"error": "Project not found"}, status=404)
    
    def post(self, request, project_id, room_id):
        """Add or update a trigger for a room."""
        try:
            project = BuildProject.objects.get(id=project_id, user=request.user)
            map_data = project.map_data or {}
            rooms = map_data.get("rooms", {})
            
            if room_id not in rooms:
                return JsonResponse({"error": "Room not found"}, status=404)
            
            # Parse trigger data
            try:
                trigger_data = json.loads(request.body)
            except json.JSONDecodeError:
                return JsonResponse({"error": "Invalid JSON"}, status=400)
            
            # Validate trigger
            is_valid, error = validate_trigger(trigger_data)
            if not is_valid:
                return JsonResponse({"error": error}, status=400)
            
            # Get existing triggers
            room_data = rooms[room_id]
            triggers = room_data.get("triggers", [])
            
            # Check for duplicate ID (update) or add new
            trigger_id = trigger_data.get("id")
            existing_idx = None
            for i, t in enumerate(triggers):
                if t.get("id") == trigger_id:
                    existing_idx = i
                    break
            
            if existing_idx is not None:
                triggers[existing_idx] = trigger_data
            else:
                triggers.append(trigger_data)
            
            # Save back to room
            room_data["triggers"] = triggers
            rooms[room_id] = room_data
            map_data["rooms"] = rooms
            project.map_data = map_data
            project.save()
            
            return JsonResponse({"success": True, "trigger": trigger_data})
            
        except BuildProject.DoesNotExist:
            return JsonResponse({"error": "Project not found"}, status=404)
    
    def delete(self, request, project_id, room_id, trigger_id=None):
        """Delete a trigger from a room."""
        if not trigger_id:
            return JsonResponse({"error": "trigger_id required"}, status=400)
        
        try:
            project = BuildProject.objects.get(id=project_id, user=request.user)
            map_data = project.map_data or {}
            rooms = map_data.get("rooms", {})
            
            if room_id not in rooms:
                return JsonResponse({"error": "Room not found"}, status=404)
            
            room_data = rooms[room_id]
            triggers = room_data.get("triggers", [])
            
            # Find and remove trigger
            new_triggers = [t for t in triggers if t.get("id") != trigger_id]
            
            if len(new_triggers) == len(triggers):
                return JsonResponse({"error": "Trigger not found"}, status=404)
            
            # Save back
            room_data["triggers"] = new_triggers
            rooms[room_id] = room_data
            map_data["rooms"] = rooms
            project.map_data = map_data
            project.save()
            
            return JsonResponse({"success": True})
            
        except BuildProject.DoesNotExist:
            return JsonResponse({"error": "Project not found"}, status=404)
```

3. Add `TriggerActionsAPI` class:
```python
class TriggerActionsAPI(LoginRequiredMixin, View):
    """
    API to get available trigger actions and conditions.
    
    GET /builder/api/trigger-metadata/
    """
    
    def get(self, request):
        """Return available actions and condition types."""
        return JsonResponse({
            "actions": list_actions(),
            "conditions": list_condition_types()
        })
```

4. Add URL patterns in urls.py for these endpoints.
  </action>
  <verify>
Check API classes added:
```bash
grep -n "class RoomTriggersAPI\|class TriggerActionsAPI" beckonmu/web/builder/views.py
```
  </verify>
  <done>
RoomTriggersAPI with GET/POST/DELETE methods, TriggerActionsAPI returning actions and conditions, validate_trigger called on save.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add trigger editor UI to builder</name>
  <files>beckonmu/web/templates/builder/editor.html</files>
  <action>
Add trigger editor panel to `beckonmu/web/templates/builder/editor.html`:

1. Add new panel in the sidebar (after V5 settings panel):

```html
<!-- Trigger Editor Panel -->
<div id="trigger-panel" class="card mb-3" style="display: none;">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h5 class="mb-0">Room Triggers</h5>
        <button type="button" class="btn btn-sm btn-primary" onclick="addTrigger()">
            + Add Trigger
        </button>
    </div>
    
    <div class="card-body" id="trigger-list">
        <!-- Triggers will be loaded here -->
        <p class="text-muted">No triggers configured.</p>
    </div>
</div>

<!-- Trigger Edit Modal -->
<div class="modal fade" id="triggerModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Edit Trigger</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            
            <div class="modal-body">
                <form id="trigger-form">
                    <input type="hidden" id="trigger-id" value="">
                    
                    <div class="mb-3">
                        <label class="form-label">Trigger Type</label>
                        <select class="form-select" id="trigger-type" onchange="onTriggerTypeChange()">
                            <option value="entry">On Entry (when someone enters)</option>
                            <option value="exit">On Exit (when someone leaves)</option>
                            <option value="timed">Timed (repeating interval)</option>
                            <option value="interaction">On Interaction (look, use, etc.)</option>
                        </select>
                    </div>
                    
                    <div class="mb-3" id="interval-field" style="display: none;">
                        <label class="form-label">Interval (seconds)</label>
                        <input type="number" class="form-control" id="trigger-interval" 
                               min="10" value="300" placeholder="300">
                        <div class="form-text">Minimum 10 seconds. 300 = 5 minutes.</div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Action</label>
                        <select class="form-select" id="trigger-action" onchange="onActionChange()">
                            <!-- Populated from API -->
                        </select>
                    </div>
                    
                    <div class="mb-3" id="action-parameters">
                        <!-- Dynamic action parameters -->
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Conditions (optional)</label>
                        <div id="conditions-list">
                            <!-- Condition rows added here -->
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-secondary" onclick="addCondition()">
                            + Add Condition
                        </button>
                    </div>
                    
                    <div class="mb-3 form-check">
                        <input type="checkbox" class="form-check-input" id="trigger-enabled" checked>
                        <label class="form-check-label" for="trigger-enabled">Enabled</label>
                    </div>
                </form>
            </div>
            
            <div class="modal-footer">
                <button type="button" class="btn btn-danger" onclick="deleteTrigger()" id="btn-delete-trigger">
                    Delete
                </button>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="saveTrigger()">Save Trigger</button>
            </div>
        </div>
    </div>
</div>
```

2. Add JavaScript for trigger management (add to existing script section):

```javascript
// Trigger management
let currentTriggers = [];
let triggerMetadata = {actions: {}, conditions: {}};
let selectedRoomId = null;

// Load trigger metadata on page load
async function loadTriggerMetadata() {
    try {
        const response = await fetch('/builder/api/trigger-metadata/');
        if (response.ok) {
            triggerMetadata = await response.json();
            populateActionSelect();
        }
    } catch (err) {
        console.error('Failed to load trigger metadata:', err);
    }
}

// Populate action dropdown
function populateActionSelect() {
    const select = document.getElementById('trigger-action');
    select.innerHTML = '';
    
    for (const [key, label] of Object.entries(triggerMetadata.actions)) {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = label;
        select.appendChild(option);
    }
}

// Show trigger panel for selected room
function showTriggerPanel(roomId) {
    selectedRoomId = roomId;
    document.getElementById('trigger-panel').style.display = 'block';
    loadTriggers(roomId);
}

// Load triggers for room
async function loadTriggers(roomId) {
    const projectId = getProjectId(); // From existing code
    
    try {
        const response = await fetch(
            `/builder/api/projects/${projectId}/rooms/${roomId}/triggers/`
        );
        
        if (response.ok) {
            const data = await response.json();
            currentTriggers = data.triggers || [];
            renderTriggerList();
        }
    } catch (err) {
        console.error('Failed to load triggers:', err);
    }
}

// Render trigger list
function renderTriggerList() {
    const container = document.getElementById('trigger-list');
    
    if (currentTriggers.length === 0) {
        container.innerHTML = '<p class="text-muted">No triggers configured.</p>';
        return;
    }
    
    let html = '';
    for (const trigger of currentTriggers) {
        const typeLabel = {
            'entry': 'On Entry',
            'exit': 'On Exit', 
            'timed': 'Timed',
            'interaction': 'On Interaction'
        }[trigger.type] || trigger.type;
        
        const enabledClass = trigger.enabled !== false ? '' : 'text-muted';
        const badge = trigger.enabled !== false ? 
            '<span class="badge bg-success">Enabled</span>' :
            '<span class="badge bg-secondary">Disabled</span>';
        
        html += `
            <div class="d-flex justify-content-between align-items-center mb-2 p-2 border rounded ${enabledClass}"
                 onclick="editTrigger('${trigger.id}')" style="cursor: pointer;">
                <div>
                    <strong>${typeLabel}</strong>
                    <div class="small">${trigger.action || 'No action'}</div>
                </div>
                ${badge}
            </div>
        `;
    }
    
    container.innerHTML = html;
}

// Add new trigger
function addTrigger() {
    document.getElementById('trigger-id').value = 'trigger_' + Date.now();
    document.getElementById('trigger-type').value = 'entry';
    document.getElementById('trigger-interval').value = '300';
    document.getElementById('trigger-enabled').checked = true;
    document.getElementById('conditions-list').innerHTML = '';
    
    onTriggerTypeChange();
    populateActionSelect();
    
    document.getElementById('btn-delete-trigger').style.display = 'none';
    
    const modal = new bootstrap.Modal(document.getElementById('triggerModal'));
    modal.show();
}

// Edit existing trigger
function editTrigger(triggerId) {
    const trigger = currentTriggers.find(t => t.id === triggerId);
    if (!trigger) return;
    
    document.getElementById('trigger-id').value = trigger.id;
    document.getElementById('trigger-type').value = trigger.type;
    document.getElementById('trigger-interval').value = trigger.interval || 300;
    document.getElementById('trigger-enabled').checked = trigger.enabled !== false;
    
    onTriggerTypeChange();
    populateActionSelect();
    
    if (trigger.action) {
        document.getElementById('trigger-action').value = trigger.action;
    }
    
    // Load conditions
    document.getElementById('conditions-list').innerHTML = '';
    if (trigger.conditions) {
        for (const condition of trigger.conditions) {
            addCondition(condition);
        }
    }
    
    document.getElementById('btn-delete-trigger').style.display = 'inline-block';
    
    const modal = new bootstrap.Modal(document.getElementById('triggerModal'));
    modal.show();
}

// Handle trigger type change
function onTriggerTypeChange() {
    const type = document.getElementById('trigger-type').value;
    const intervalField = document.getElementById('interval-field');
    
    intervalField.style.display = type === 'timed' ? 'block' : 'none';
}

// Add condition row
function addCondition(condition = null) {
    const container = document.getElementById('conditions-list');
    const id = 'cond_' + Date.now();
    
    let options = '';
    for (const [key, info] of Object.entries(triggerMetadata.conditions)) {
        options += `<option value="${key}"${condition && condition.type === key ? ' selected' : ''}>${info.label}</option>`;
    }
    
    const div = document.createElement('div');
    div.className = 'mb-2 p-2 border rounded';
    div.innerHTML = `
        <div class="row g-2">
            <div class="col-4">
                <select class="form-select form-select-sm" onchange="onConditionTypeChange('${id}')" id="${id}_type">
                    ${options}
                </select>
            </div>
            <div class="col-6" id="${id}_params">
                <!-- Dynamic parameters -->
            </div>
            <div class="col-2">
                <button type="button" class="btn btn-sm btn-outline-danger" onclick="this.closest('.mb-2').remove()">
                    Ã—
                </button>
            </div>
        </div>
    `;
    
    container.appendChild(div);
    
    if (condition) {
        onConditionTypeChange(id, condition.parameters);
    } else {
        onConditionTypeChange(id);
    }
}

// Save trigger
async function saveTrigger() {
    const projectId = getProjectId();
    
    const triggerData = {
        id: document.getElementById('trigger-id').value,
        type: document.getElementById('trigger-type').value,
        action: document.getElementById('trigger-action').value,
        enabled: document.getElementById('trigger-enabled').checked,
        parameters: {}, // Gather from action parameter fields
        conditions: []  // Gather from condition rows
    };
    
    if (triggerData.type === 'timed') {
        triggerData.interval = parseInt(document.getElementById('trigger-interval').value) || 300;
    }
    
    // TODO: Gather conditions and action parameters from form
    
    try {
        const response = await fetch(
            `/builder/api/projects/${projectId}/rooms/${selectedRoomId}/triggers/`,
            {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(triggerData)
            }
        );
        
        if (response.ok) {
            bootstrap.Modal.getInstance(document.getElementById('triggerModal')).hide();
            loadTriggers(selectedRoomId);
        } else {
            const error = await response.json();
            alert('Error: ' + (error.error || 'Unknown error'));
        }
    } catch (err) {
        console.error('Failed to save trigger:', err);
        alert('Failed to save trigger');
    }
}

// Delete trigger
async function deleteTrigger() {
    const triggerId = document.getElementById('trigger-id').value;
    const projectId = getProjectId();
    
    if (!confirm('Delete this trigger?')) return;
    
    try {
        const response = await fetch(
            `/builder/api/projects/${projectId}/rooms/${selectedRoomId}/triggers/${triggerId}/`,
            {method: 'DELETE'}
        );
        
        if (response.ok) {
            bootstrap.Modal.getInstance(document.getElementById('triggerModal')).hide();
            loadTriggers(selectedRoomId);
        }
    } catch (err) {
        console.error('Failed to delete trigger:', err);
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', loadTriggerMetadata);
```

3. Update room selection handler to show trigger panel:
   Find the room selection code and add: `showTriggerPanel(roomId);`
  
  </action>
  <verify>
Check trigger panel HTML added:
```bash
grep -n "trigger-panel\|Room Triggers\|triggerModal" beckonmu/web/templates/builder/editor.html | head -20
```
  </verify>
  <done>
Trigger panel HTML exists with type selector, action dropdown, conditions UI, interval field for timed triggers, modal for add/edit/delete.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add URL routes for trigger API</name>
  <files>beckonmu/web/builder/urls.py</files>
  <action>
Update `beckonmu/web/builder/urls.py` to add trigger API routes:

```python
from django.urls import path
from . import views

urlpatterns = [
    # ... existing patterns ...
    
    # Trigger metadata
    path('api/trigger-metadata/', views.TriggerActionsAPI.as_view(), name='trigger_metadata'),
    
    # Room triggers
    path('api/projects/<int:project_id>/rooms/<str:room_id>/triggers/', 
         views.RoomTriggersAPI.as_view(), name='room_triggers'),
    path('api/projects/<int:project_id>/rooms/<str:room_id>/triggers/<str:trigger_id>/', 
         views.RoomTriggersAPI.as_view(), name='room_trigger_detail'),
]
```
  </action>
  <verify>
Check URL patterns added:
```bash
grep -n "trigger-metadata\|room_triggers" beckonmu/web/builder/urls.py
```
  </verify>
  <done>
URL routes exist for trigger-metadata and room_triggers (GET/POST/DELETE).
  </done>
</task>

</tasks>

<verification>
**Automated checks:**
```bash
# Check all files exist
ls beckonmu/web/builder/v5_conditions.py
ls beckonmu/web/builder/views.py
ls beckonmu/web/templates/builder/editor.html

# Check v5_conditions imports
python -c "from beckonmu.web.builder.v5_conditions import check_condition, list_condition_types; print('v5_conditions OK')"

# Check API endpoints exist
python -c "from beckonmu.web.builder.views import RoomTriggersAPI, TriggerActionsAPI; print('API views OK')"

# Check URL patterns
python -c "from beckonmu.web.builder.urls import urlpatterns; print('URLs OK')"
```

**Manual verification:**
1. Open builder editor, select a room
2. Trigger panel should appear
3. Add trigger button opens modal
4. Can select type, action, add conditions
5. Save creates trigger, appears in list
6. Trigger data saved to map_data
</verification>

<success_criteria>
- [ ] v5_conditions.py with 7+ condition types (clan, splat, hunger, room_type, time_of_day, danger, probability)
- [ ] check_condition() function validates all condition types
- [ ] trigger_engine validates conditions before execution
- [ ] RoomTriggersAPI with GET/POST/DELETE endpoints
- [ ] TriggerActionsAPI returns actions and condition metadata
- [ ] Trigger editor UI panel in builder
- [ ] Modal for adding/editing triggers
- [ ] Type selector (entry/exit/timed/interaction)
- [ ] Action dropdown populated from ACTION_REGISTRY
- [ ] Conditions UI with add/remove
- [ ] Interval field shows for timed triggers
- [ ] Trigger data validates before save
- [ ] URL routes configured for API endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/07-trigger-system/07-03-SUMMARY.md`
</output>
